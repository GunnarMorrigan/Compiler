
printTillN (n) :: Int -> Void {
	Int x = 0;

	while ((x < n)) {
		print(x);
		x = (x + 1);
	}
	return;
}

editTuple (tuple, flip) :: (Int, Int) -> Bool -> (Int, Int) {
	(Int, Int) returnVar = (0, 0);

	if (flip) {
		returnVar = (tuple.snd, tuple.fst);
		return returnVar;
	} else {
		if ((flip.fst == flip.snd)) {
			returnVar = removeFirst(flip);
			return returnVar;
		}
	}
	return tuple;
}

niceFunction (a, b, n) :: [Char] -> Bool -> Int -> Void {
	[Char] c = a.hd;

	if (a.isEmpty) {
		return;
	}
	if ((c.tl.hd == 'a')) {
		return;
	}
	print(c);
}
